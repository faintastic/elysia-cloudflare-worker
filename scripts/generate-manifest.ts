#!/usr/bin/env bun
/**
 * Manifest Generator Script
 * 
 * Automatically generates src/lib/discord/manifest.ts by scanning handler directories.
 * Run this script whenever you add new commands, buttons, modals, or select menus.
 * 
 * Usage: bun run scripts/generate-manifest.ts
 */

import { existsSync, readdirSync, writeFileSync } from 'fs';
import { join, basename } from 'path';

const ROOT_DIR = join(import.meta.dir, '..');
const HANDLERS_DIR = join(ROOT_DIR, 'src');
const MANIFEST_PATH = join(ROOT_DIR, 'src/lib/discord/manifest.ts');

interface HandlerInfo {
  fileName: string;
  importName: string;
  importPath: string;
}

// Reserved JavaScript keywords and common conflicts
const RESERVED_WORDS = new Set(['delete', 'import', 'export', 'default', 'class', 'function', 'return', 'if', 'else', 'for', 'while', 'break', 'continue', 'switch', 'case']);

/**
 * Convert a filename to a valid JavaScript identifier
 */
function toValidIdentifier(fileName: string, type: string): string {
  // Remove extension
  let name = fileName.replace(/\.(ts|js)$/, '');
  
  // Convert kebab-case and snake_case to camelCase
  name = name.replace(/[-_]([a-z])/g, (_, letter) => letter.toUpperCase());
  
  // If it's a reserved word or conflicts, add type suffix
  if (RESERVED_WORDS.has(name)) {
    return name + type.charAt(0).toUpperCase() + type.slice(1);
  }
  
  return name;
}

/**
 * Scan a directory for handler files
 */
function scanHandlers(directory: string, handlerType: string): HandlerInfo[] {
  const dirPath = join(HANDLERS_DIR, directory);
  
  if (!existsSync(dirPath)) {
    console.warn(`âš ï¸  Directory not found: ${directory}`);
    return [];
  }
  
  const files = readdirSync(dirPath)
    .filter(file => file.endsWith('.ts') || file.endsWith('.js'))
    .filter(file => !file.endsWith('.d.ts')); // Skip type definition files
  
  return files.map(file => {
    const importName = toValidIdentifier(file, handlerType);
    const fileNameWithoutExt = file.replace(/\.(ts|js)$/, '');
    
    return {
      fileName: file,
      importName,
      importPath: `../../${directory}/${fileNameWithoutExt}`
    };
  }).sort((a, b) => a.fileName.localeCompare(b.fileName));
}

/**
 * Generate the manifest file content
 */
function generateManifest(): string {
  const commands = scanHandlers('commands', 'Command');
  const buttons = scanHandlers('buttons', 'Button');
  const modals = scanHandlers('modals', 'Modal');
  const selects = scanHandlers('select-menus', 'Select');
  
  const allHandlers = [...commands, ...buttons, ...modals, ...selects];
  
  if (allHandlers.length === 0) {
    console.warn('âš ï¸  No handlers found!');
  }
  
  let content = `/**
 * Static Handler Manifest
 * 
 * This file is AUTO-GENERATED by scripts/generate-manifest.ts
 * DO NOT EDIT MANUALLY - your changes will be overwritten!
 * 
 * To regenerate this file, run: bun run generate-manifest
 * 
 * This manifest explicitly imports and exports all interaction handlers for Cloudflare Workers.
 * Unlike the dynamic loader that uses Bun.Glob (which doesn't work in Workers), this manifest
 * statically imports all handlers at build time, ensuring they're bundled into the Worker.
 * 
 * @module manifest
 * @generated
 */

`;

  // Generate imports section
  if (commands.length > 0) {
    content += `// Command imports (${commands.length})\n`;
    commands.forEach(handler => {
      content += `import ${handler.importName} from '${handler.importPath}';\n`;
    });
    content += '\n';
  }
  
  if (buttons.length > 0) {
    content += `// Button imports (${buttons.length})\n`;
    buttons.forEach(handler => {
      content += `import ${handler.importName} from '${handler.importPath}';\n`;
    });
    content += '\n';
  }
  
  if (modals.length > 0) {
    content += `// Modal imports (${modals.length})\n`;
    modals.forEach(handler => {
      content += `import ${handler.importName} from '${handler.importPath}';\n`;
    });
    content += '\n';
  }
  
  if (selects.length > 0) {
    content += `// Select menu imports (${selects.length})\n`;
    selects.forEach(handler => {
      content += `import ${handler.importName} from '${handler.importPath}';\n`;
    });
    content += '\n';
  }
  
  // Type imports
  content += `import type { Command, Button, Modal, Select } from './loader';\n\n`;
  
  // Generate exports section
  content += `/**\n * Array of all command handlers.\n */\n`;
  content += `export const commands: Command[] = [\n`;
  if (commands.length > 0) {
    commands.forEach(handler => {
      content += `  ${handler.importName},\n`;
    });
  }
  content += `];\n\n`;
  
  content += `/**\n * Array of all button handlers.\n */\n`;
  content += `export const buttons: Button[] = [\n`;
  if (buttons.length > 0) {
    buttons.forEach(handler => {
      content += `  ${handler.importName},\n`;
    });
  }
  content += `];\n\n`;
  
  content += `/**\n * Array of all modal handlers.\n */\n`;
  content += `export const modals: Modal[] = [\n`;
  if (modals.length > 0) {
    modals.forEach(handler => {
      content += `  ${handler.importName},\n`;
    });
  }
  content += `];\n\n`;
  
  content += `/**\n * Array of all select menu handlers.\n */\n`;
  content += `export const selects: Select[] = [\n`;
  if (selects.length > 0) {
    selects.forEach(handler => {
      content += `  ${handler.importName},\n`;
    });
  }
  content += `];\n`;
  
  return content;
}

/**
 * Main execution
 */
function main() {
  console.log('ðŸ” Scanning handler directories...\n');
  
  const commands = scanHandlers('commands', 'Command');
  const buttons = scanHandlers('buttons', 'Button');
  const modals = scanHandlers('modals', 'Modal');
  const selects = scanHandlers('select-menus', 'Select');
  
  console.log(`Found handlers:`);
  console.log(`  ðŸ“‹ Commands: ${commands.length}`);
  console.log(`  ðŸ”˜ Buttons: ${buttons.length}`);
  console.log(`  ðŸ“ Modals: ${modals.length}`);
  console.log(`  ðŸ“‘ Select menus: ${selects.length}`);
  console.log(`  â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”`);
  console.log(`  ðŸ“¦ Total: ${commands.length + buttons.length + modals.length + selects.length}\n`);
  
  console.log('âœï¸  Generating manifest.ts...');
  const manifestContent = generateManifest();
  
  writeFileSync(MANIFEST_PATH, manifestContent, 'utf-8');
  
  console.log(`âœ… Successfully generated: ${MANIFEST_PATH}\n`);
  
  // List all handlers
  if (commands.length > 0) {
    console.log('Commands:');
    commands.forEach(h => console.log(`  - ${h.fileName.replace(/\.(ts|js)$/, '')}`));
  }
  if (buttons.length > 0) {
    console.log('\nButtons:');
    buttons.forEach(h => console.log(`  - ${h.fileName.replace(/\.(ts|js)$/, '')}`));
  }
  if (modals.length > 0) {
    console.log('\nModals:');
    modals.forEach(h => console.log(`  - ${h.fileName.replace(/\.(ts|js)$/, '')}`));
  }
  if (selects.length > 0) {
    console.log('\nSelect menus:');
    selects.forEach(h => console.log(`  - ${h.fileName.replace(/\.(ts|js)$/, '')}`));
  }
  
  console.log('\nâœ¨ Done! You can now deploy with: bun run deploy');
}

main();
